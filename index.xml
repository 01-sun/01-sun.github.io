<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LITOU&#39;s BLOG</title>
    <link>https://01-sun.github.io/</link>
    <description>Recent content on LITOU&#39;s BLOG</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 28 Jun 2021 11:20:11 +0800</lastBuildDate><atom:link href="https://01-sun.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>UE4-总结</title>
      <link>https://01-sun.github.io/post/ue4-%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 28 Jun 2021 11:20:11 +0800</pubDate>
      
      <guid>https://01-sun.github.io/post/ue4-%E6%80%BB%E7%BB%93/</guid>
      <description>GamePlay框架
反射系统
网络模块
UI模块
技能模块
蒙太奇
C++蓝图互调
没有UFUNCTION影响
ActorComponent和SceneComponent
setVisible
命名规范
 网络模块 Actor Replication 设置actor:replicate = true
让actor所有者得到同步: netrelevant
Property Replication 只有将属性标记Replicated，才会复制
两种同步属性方式:
  服务器变化，同步客户端
  属性发生变化，调用ONRep_函数()
  function call replication PRCs 是一种将函数调用和执行分开的方式。
 UI模块   Slate:C++写
  UMG: 图形界面
   技能模块 获得技能 拥有者继承UAbilitySystemComponent类 做成单例去定义获取技能GetAbility()
技能继承GamePlayAbility类 * 释放技能效果 EventActiveAbility() * 技能结束 EventOnEndAbility()
施放技能 调用TryActiveAbilityByClass()调用效果commitAbility commitAbilityCoolDown结束技能 EndAbility 技能消耗CD 消耗CD继承AbilityEffect类
CD的类duration policy选择hasduration,当技能释放会给技能槽一个独占Tag，只有等技能结束Tag消失，才能再次复制Tag</description>
    </item>
    
    <item>
      <title>图形学-总结</title>
      <link>https://01-sun.github.io/post/%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 28 Jun 2021 10:40:11 +0800</pubDate>
      
      <guid>https://01-sun.github.io/post/%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E6%80%BB%E7%BB%93/</guid>
      <description>矩阵求逆
[矩阵求转置]](#矩阵求转置)
冯氏光照模型
[深度测试和模板测试]](#深度测试和模板测试)
剔除三剑客
[骨骼动画原理]](#骨骼动画原理)
判断点在多边形内
[判断凹多边形和凸多边形]](#判断凹多边形和凸多边形)
 矩阵求逆 手算: * 待定系数法
* 伴随矩阵法 =A* 1/|A|* 初等变换法 A A* = E 机算:
* lu分解法* GJ消去法  矩阵求转置   三元组法
  压缩矩阵快速转置法
   冯氏光照模型   Ambient(环境光): 由环境因子决定
  Diffuse(反射光): 由法向量和光照方向决定
  Specular(高光): 由反射向量和视向量决定
   深度测试和模板测试 深度测试: 计算当前像素是否被下一像素覆盖是的过程。 z-buffer只用正确渲染，而不用于性能优化
模板测试: 用该像素的模板值和参考模板值对比，符合留下，不符合条件丢弃。
 剔除三剑客 视锥体剔除 How:
* 取包围盒的对角线点是否在视锥体内 --&amp;gt; 点在视锥体内 --&amp;gt; 点在面前面* 点在远近剪裁面内 背面剔除 How: 面法线和视向量夹角，大于90°是背面，反之正面</description>
    </item>
    
    <item>
      <title>C&#43;&#43;-总结</title>
      <link>https://01-sun.github.io/post/c&#43;&#43;-%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 28 Jun 2021 09:00:11 +0800</pubDate>
      
      <guid>https://01-sun.github.io/post/c&#43;&#43;-%E6%80%BB%E7%BB%93/</guid>
      <description>抽象类和接口
单例模式
大小端
超前引用
const用法
lambda
 抽象类和接口 抽象类:含纯虚函数
接口: 都是纯虚函数
纯虚函数: 父类定义，由子类实现
 单例模式 Why:避免频繁使用的类被频繁创建释放
What:就是自行创建唯一实例，并向整个系统提供这个实例
写法:
class A{ public: static A *instance; static A* getInstance(){ if(instance==nullptr) instance = new A(); returhn instance; } private: A(); A(const A&amp;amp;); A&amp;amp; oprator=(const A&amp;amp;); } 注意：单例应该只用来保存全局的状态，并且不能和任何作用域绑定。如果这些状态的作用域比一个完整的应用程序的生命周期要短，那么这个状态就不应该使用单例来管理。
 大小端 小端:低地址低字节，使用内存运算
大端:低地址高字节，适用于数据运算，快速判断数据正负大小
 超前引用 What:类A和类B需要彼此互相引用，这样必然有一个类A会先被定义，而另外一个类B后被定义，这样在先被定义的类引用后被定义的类的时候，就导致了所谓的超前引用。
How:
  用之前先声明class B
  使用全局变量 extern
   const用法 目的:常量不让改变
const char str[] = &amp;ldquo;1234&amp;rdquo;; //const修饰str的值，不允许值被修改</description>
    </item>
    
    <item>
      <title>cocos2dx-总结</title>
      <link>https://01-sun.github.io/post/cocos2dx-%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 28 Jun 2021 09:00:11 +0800</pubDate>
      
      <guid>https://01-sun.github.io/post/cocos2dx-%E6%80%BB%E7%BB%93/</guid>
      <description>渲染流程
内存管理
主循环工作
定时器
 渲染流程 directoe.mainloop()进入主循环 &amp;ndash;&amp;gt; director.drawScene() &amp;ndash;&amp;gt; Scene.render() &amp;ndash;&amp;gt;Node.visit() &amp;ndash;&amp;gt;sprite.draw()
&amp;ndash;&amp;gt;addcommand到渲染队列 &amp;ndash;&amp;gt;进行合批 &amp;ndash;&amp;gt;调用渲染API进行渲染
 内存管理 方法:引用计数
手动:
* 初始值为0,create/retain： +1, release:-1. 自动:(自动回收池) * 使用create()会调用autorelease()会加入到自动回收池，初始计数为1。
* 被引用retain： +1, 被释放release:-1。* 每帧结束后会调用release()进行-1，为零则会被清除。  主循环工作 1.处理输入输出
2.渲染
3.处理定时器
 定时器   update 每帧调用
  schedule 自定义时间调用
  </description>
    </item>
    
    <item>
      <title>lua-总结</title>
      <link>https://01-sun.github.io/post/lua-%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 28 Jun 2021 08:00:11 +0800</pubDate>
      
      <guid>https://01-sun.github.io/post/lua-%E6%80%BB%E7%BB%93/</guid>
      <description>检测内存泄漏
_newindex
协程
 检测内存泄漏   快照:扫描间隔两端时间的内存快照，一直存在可能是内存泄漏
  弱表:建立一张全局的弱表，把资源放进去然后运行游戏后进行GC，若有对象没被施放，可能存在内存泄露
   _newindex 目的:防止被乱插值，表受污染
What:用于更新。
* 当给表缺少索引的键赋值,若存在_newindex,则赋值失败。* 如果_newindex是表，赋值会在该表中  协程 * 协同程序却需要彼此协作的运行* 一个时间只有一个携程在运行* 并且必须显示挂起。resume运行create操作，遇到yeild挂起等待下一个resume </description>
    </item>
    
    <item>
      <title>游戏客户端-总结</title>
      <link>https://01-sun.github.io/post/%E6%B8%B8%E6%88%8F%E5%AE%A2%E6%88%B7%E7%AB%AF-%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 27 Jun 2021 01:50:11 +0800</pubDate>
      
      <guid>https://01-sun.github.io/post/%E6%B8%B8%E6%88%8F%E5%AE%A2%E6%88%B7%E7%AB%AF-%E6%80%BB%E7%BB%93/</guid>
      <description>UI优化
客户端优化
性能测试工具
移动端纹理压缩格式
网络同步方案
常见算法
名词解释
 UI优化 目的：加快UI运行速度
  动静分离
  渲染层和逻辑层分离
  合并图集
  How：同一层ui的散图可合并
  Why：来自同一图集使用一次drawcall；节省内存(多于白边，多余图片信息)
    减少UI层次： 不同层不同drawcall
   客户端优化 目的：减少手机发热
  减少GPU渲染：
  减少多余点面，可用低模+法线贴图(就是将复杂物体的凹凸信息记录到图片的rgb通道里面)
  不用实时光照，使用烘焙光照
  不使用透明材质
  使用HLOD，MipMAp
  使用2的幂次方尺寸的贴图(方便光栅化采样,驱动优化时会把不是2的幂次方的图转成2的幂次方的图,浪费性能)
    减少CPU计算：
  合批
  代码优化
     性能测试工具 目的：检测游戏性能</description>
    </item>
    
    <item>
      <title>UE4动画制作-教程</title>
      <link>https://01-sun.github.io/post/ue4-%E8%A7%92%E8%89%B2%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Sun, 06 Jun 2021 01:50:11 +0800</pubDate>
      
      <guid>https://01-sun.github.io/post/ue4-%E8%A7%92%E8%89%B2%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/</guid>
      <description>游戏动画
UE4的角色动画实现-骨骼动画
游戏动画   what：动作过程。
  why:实现游戏角色的走、跑、游泳、攻击等行为。
  how：帧动画、骨骼动画等。
  主要动画分类： 帧动画：
  What：帧动画的每一帧都是角色特定姿势的一个快照，帧动画的每一帧都是角色特定姿势的一个快照，动画的流畅性和平滑效果都取决于帧数的多少。常见于cocos2dx引擎
  Advantage：1、适合需要复杂细腻的效果。2、可添加事件
  Diadvantage：1、耗内存。2、不灵活
  骨骼动画：
  what：而骨骼动画则是把角色的各部分身体部件图片绑定到一根根互相作用连接的“骨头”上，通过控制这些骨骼的位置、旋转方向和放大缩小而生成的动画。
  Advantage：1、内存少 2、灵活（混合动画）
  Diadvantage：1、更高的处理器。
   UE4的角色动画实现-骨骼动画 几个概念 ：   骨骼/骨架(skelton)：骨骼动画的基础，能挂载动画，用于生成动画序列
  动画序列（animation sequence）：某个骨骼动画
  混合空间（Blend Space）：两个骨骼动画之间创建过渡动画
  动画蓝图（Animation Blueprint）:添加运行动画的条件，实现逻辑动画
  根骨骼位移（Root Motion）:解决位移和动画不一致问题，简单动作可以不用 详细
  流程 ：   获取3d模型：</description>
    </item>
    
    <item>
      <title>Lua设计与实现-笔记</title>
      <link>https://01-sun.github.io/post/lua%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 24 Feb 2021 08:24:11 +0800</pubDate>
      
      <guid>https://01-sun.github.io/post/lua%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E7%AC%94%E8%AE%B0/</guid>
      <description>前言 用了一年多的lua，却对这个语言只是止于使用，乘着过年放假，把这本《lua设计与实现》读完。作者用最通俗易懂的语言讲述lua的底层实现，对lua从数据类型到虚拟机，再到回收机制进行层层剖析，使得笔者对lua有大体了解，而又好记性不如烂笔头，因此作此笔记。
 通用数据类型 目标： 不同时刻同一变量指向不同数据类型
思路：需要两个字段，一个存储数据类型，一个存储数据
实现：通过union和struct，之间嵌套、有机结合形成lua_TValue，来统一表示所有数据类型。可进行GC（垃圾回收）操作的数据有CommonHeader宏定义的成员
注：number不是可GC类型
lua通用数据结构组织（如图）
 字符串-string 目标：尽可能提高效率存储字符串
思路：存储字符串的变量是对该字符串的引用，所以需要两个字段，一个存储字符串的长度，一个存储字符串数据的引用（散列值）
实现：
typedef uinion TString{ L_Umaxalign dumy; //对齐变量 （节省空间）  struct{ commonHeader; //GC宏  lu_byte reserved; //表示是不是保留字符串  unsigned int hash;//散列值  size_t len; //字符串长度  }tsu; }TString; 特点：
“内化”：字符串变量是对字符串的引用，当创建字符串前先检查全局数据区有无该串，无则创建，有则引用。（ps：用时间换空间，同时lua的查找算法效率也很高）
“散列值”：加快对字符串数据比较和查找
存储：
所有字符串存储在全局数据区，该区为全局变量global_state的str成员,str本质为散列数组
typedef struct stringtable{ GCObject **hash; lu_int32 nuse; //元素值  int size; }stringtable; 创建字符串Tstring，首先根据散列算法算出散列值，为str的索引值，若位置上已有值，则用链表串联起来
rehash（重新哈希）:当散列桶中数量非常大，算法效率急速下降，所以需要重新分配散列桶数量，来降低每个桶中的数量（luaS_resize()）
lua_Tip:
尽量少用大量循环来连接字符串，因为每次连接都会产生新串，费时又费空间。而用表来做字符串缓冲区（先用表循环存储，再用table.concat连接），会节省空间,提高效率。
 表-table 目标：存储所有数据类型，并对使用者透明
思路：两个部分，分数组和散列表
实现：
type struct Table{ CommonHeader; lu_byte flags; //提供元方法标志  lu_byte lsizenode; //以2为第的散列桶大小  struct Table *metable; //远比闹  TValue *array; //数组部分指针  Node *node; //散列桶起始位置  Node *lastfree; //散列桶最后位置  GCObject *gclist; int sizearray; //数组部分大小 } 重要操作</description>
    </item>
    
  </channel>
</rss>
